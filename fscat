#!/usr/bin/python

import os,sys,re
from glob import glob
from shutil import rmtree
from xml.dom import minidom
import logging

__author__  = "Dario Chiappetta"
__email__   = "dario@repni.it"
__version__ = "0.1"
__status__  = "development"

DIR_DATA    = "_data/"
DIR_IDX     = "./"
DIR_IDX_AZ  = DIR_IDX+"by_title/"
DIR_IDX_GEN = DIR_IDX+"by_genre/"
CONFFILE    = ".fscat.conf"
METAFILE    = ".meta"			# TODO: change in .fscat.meta

KW_STOP = "S"
KW_SKIP = "K"

UNDEFINED_NAME = "_UNDEFINED_"

#
# COMMANDS
#

def build_indices(root = "./"):
	"""
	Crawls the subfolders of the current working directory (not recursively)
	searching for metafiles. When a metafile is found, the corresponding film
	is added to the index.
	"""
	
	logging.debug("Indices build started")
	
	root     = os.path.abspath(root)+"/"
	dataroot = root+DIR_DATA
	
	collection = get_collection_from_XML(root+CONFFILE)
	if not collection:
		logging.error("Errors occurred reading collection's configuration file. Aborting.")
		return False

	"""Remove existing indices, if present"""
	for i in collection.indices:
		if os.path.exists(i.root):
			print("Old index found: must be removed to continue.")
			if not yn_remove_folder(i.root):
				return False	
			
	"""Build the updated indices"""
	for d in [x[0] for x in os.walk(dataroot)][1:]:
		d = d+"/"
		movies = get_movies_from_XML(d+METAFILE)
		if movies:
			for m in movies:
				#~ add_to_index_az(d+"/",m)
				#~ add_to_index_gen(d+"/",m)
				for i in collection.indices:
					add_to_index(d,m,i)
			
	return True

def edit_meta(movieroot = "./"):
	"""
	Edit the metadata for the movie in the specified directory. Create metadata
	file if not already present.
	"""
	
	logging.debug("Editing metadata for movie in the current folder")

	"""Enforce trailing slash in path"""
	movieroot = os.path.abspath(movieroot)+"/"

	"""If metadata already present, resue information"""
	# TODO: now get_movies_from_XML() returns a list, following code must be 
	#       updated
	m = get_movies_from_XML(movieroot+METAFILE)
	if m:
		p_title = m.title
		p_year  = m.year
		p_genre = m.genre
		p_files = m.files
	else:
		p_title, p_year, p_genre, p_files = guess_meta(movieroot)

	n_title = input("title: ["+p_title+"] ")
	if n_title == "":
		n_title = p_title
	
	n_year  = input("year: ["+p_year+"] ")
	if n_year == "":
		n_year = p_year
		
	n_genre = input("genre: ["+p_genre+"] ")
	if n_genre == "":
		n_genre = p_genre
	
	filelist = []
	stop = False
	for f in p_files:
		filename_in = input("file ("+KW_STOP+" to terminate, "+KW_SKIP+" to skip): ["+f+"] ")
		
		if filename_in == KW_STOP:
			stop = True
			break
		
		if filename_in is not KW_SKIP:
			filelist.append(f)
	
	filename_in = None
	while True:
		if stop or filename_in == KW_STOP:
			break
		
		if filename_in and filename_in is not "":
			filelist.append(filename_in)
		
		filename_in = input("file ("+KW_STOP+" to terminate): ")
	
	n_movie = Movie(n_title, n_year, n_genre, filelist)
		
	print(n_movie.get_xml())
	
	stop = False
	while stop == False:
		write_yn = input("\nCorrect? [Y/n] ")
		
		if (write_yn == "") or (write_yn.lower() == "y"):
			stop = True
			metafile = open(movieroot+METAFILE,"w")
			metafile.write(n_movie.get_xml())
			metafile.close()
			print("Metadata written to "+movieroot+METAFILE)
		elif write_yn.lower() == "n":
			stop = True
			print("Metadata were not updated")
		else:
			print("Invalid input. Please answer with 'y' or 'n'.")
		

def init_meta(dataroot = DIR_DATA):
	"""
	Loops (not recursively) through the subdirectories of 'dataroot', creating
	metadata for each folder (or editing them, if already present)
	"""
	
	"""Check if data directory exists"""
	if not os.path.exists(dataroot):
		logging.error("Invalid data directory: "+os.path.abspath(dataroot))
		return False
	
	"""Build the updated index"""
	for d in [x[0] for x in os.walk(dataroot)][1:]:
		
		stop = False
		while not stop:
			edit_yn = input("Edit metadata for "+os.path.abspath(d)+"? [y/N] ")
			
			if (edit_yn.lower() == "y"):
				stop = True
				edit_meta(d)
			elif (edit_yn.lower() == "") or (edit_yn.lower() == "n"):
				stop = True
				print("Skipping.")
			else:
				print("Invalid input. Please answer with 'y' or 'n'.")
			
		print()
		
	return True

#
# UTIL_EDIT
# Utility methods for the 'edit' command
#

def guess_meta(movieroot):
	"""
	Guesses the metadata from file and folder names
	"""
	
	"""files: all the possible video and subtitle files"""
	# FIXME: glob looks in current directory, instead of movie root
	files = glob(movieroot + "*.avi") + \
	        glob(movieroot + "*.mkv") + \
	        glob(movieroot + "*.mp4") + \
	        glob(movieroot + "*.srt")
	
	files = [os.path.basename(x) for x in files]
	
	"""title: the folder name"""
	title = movieroot.split("/")[-2]

	"""year: most frequent year match in video files or folder name"""
	year = ""
	candidate_years = []
	for i in files + [title]:
		candidate_years = candidate_years + re.findall(r"[1-2][0-9]{3}", i)
	if len(candidate_years) > 0:
		year = max(set(candidate_years), key=candidate_years.count)
	
	"""genre: not guessed at the moment..."""
	genre = ""
	
	return title, year, genre, files

#
# UTIL_BUILD
# Utility methods for the 'build' command
#

def yn_remove_folder(path):
	ans = input("Remove '"+path+"' and its content? [y/N] ")
	if (ans.lower() == 'y'):
		rmtree(path)
		return True
	elif (ans.lower() == 'n' or ans == ''):
		return False
	else:
		print("Please answer with 'y' or 'n'.")
		return yn_remove_folder(path)

def add_to_index(src_path, movie, index):
	
	"""Extract features from movie"""
	f = {}
	f["TITLE"]   = movie.title
	f["YEAR"]    = movie.year
	f["GENRE"]   = movie.genre
	f["INITIAL"] = movie.title[0].upper()
	
	"""Build path by replacing features in the definition"""
	idx_path = index.path
	for k in f.keys():
		idx_path = idx_path.replace("$"+k,f[k])
	
	idx_path = index.root+idx_path
	
	"""Create the index directory, if not already existing"""
	if not os.path.exists(idx_path):
		os.makedirs(idx_path)
		
	"""Create a hardlink to the movie file(s)"""
	for f in movie.files:
		try:
			os.link(src_path+f,idx_path+f)
		except FileNotFoundError:
			logging.warning("File not found: "+src_path+f+". Skipped. It is recommended to update movie entry.")

	logging.debug("Added '"+movie.title+"' to index '"+index.name+"' ("+idx_path+")")

#
# FACTORY
#

def get_movies_from_XML(filename):
	"""
	Returns a list of Movie objects built upon the <movie> entries found in the
	given .meta description file
	"""
	
	if not os.path.isfile(filename):
		return False
	
	try:
		meta = minidom.parse(filename)
	except:
		logging.warning("Invalid content for metafile: "+filename)
		return False
	
	r = []
	
	"""For every <media> element in the metafile"""
	medias = meta.getElementsByTagName("media")
	for media in medias:
		"""Get the movie files (there can be 1 or more)"""
		files = []
		elements = media.getElementsByTagName("file")
		for tag in elements:
			assert tag.childNodes[0].nodeType == tag.childNodes[0].TEXT_NODE
			files.append(tag.childNodes[0].data)
		
		"""Get the other properties"""
		properties = {}
		for p in Movie.PROPERTIES:
			elements = media.getElementsByTagName(p)
			
			assert len(elements) == 1
			tag = elements[0]
			
			try:
				assert tag.childNodes[0].nodeType == tag.childNodes[0].TEXT_NODE
				properties[p] = tag.childNodes[0].data
			except IndexError:
				logging.warning("Empty value for property '"+p+"' in metafile "+filename)
				properties[p] = ""
		
		"""Builds and appends a Movie object representing the <media> entry"""
		r.append(Movie(properties["title"],properties["year"],properties["genre"], files))
	
	return r

def get_collection_from_XML(filename):
	"""
	Returns a Collection object built from the collection's configuration file,
	.fscat.conf
	"""

	if not os.path.isfile(filename):
		logging.warning("Impossible to open '"+filename+"' for reading.")
		return False
	
	try:
		conf = minidom.parse(filename)
	except:
		logging.warning("Invalid content for configuration file: "+filename)
		return False
	
	"""Get the main <collection> tag"""
	collection = conf.getElementsByTagName("collection")
	assert len(collection) == 1
	collection = collection[0]
	name_processed = False
	
	"""Process the content of the collection"""
	name    = None
	indices = []
	for node in collection.childNodes:
		if node.localName == "index":
			i = _get_index_from_XML_element(node, filename)
			if i:
				indices.append(i)
			
		elif node.localName == "name":
			if name_processed:
				logging.warning("Duplicate 'name' entry in '"+filename+"'")
			name = _get_XML_tag_value(node)
			name_processed = True
		
		elif node.localName is not None:
			logging.warning("Unknown tag '"+node.localName+"' in '"+filename+"'. Skipping.")

	if not name:
		logging.warning("Missing 'name' tag for collection in '"+filename+"'")
		name = UNDEFINED_NAME
	if len(indices) == 0:
		logging.warning("No index defined in '"+filename+"'")
		return False
	
	return Collection(name,indices)
	

def _get_index_from_XML_element(element, source = None):
	"""
	Builds and returns a CollectionIndex object from a <index> element (supposed
	to be found in the collection's .fscat.conf), as it is parsed by minidom.
	
		'element'	Is the Dom Element containing the index
		'source'	Is the path to the XML, used for error messages
	"""
	
	name = None
	root = None
	path = None
	
	"""Extract information from XML"""
	name_processed = False
	root_processed = False
	path_processed = False
	for node in element.childNodes:
		if node.localName == "name":
			if name_processed:
				logging.warning("Duplicate entry 'name' in '"+source+"'")
			name = _get_XML_tag_value(node)
			name_processed = True
			
		elif node.localName == "root":
			if root_processed:
				logging.warning("Duplicate entry 'root' in '"+source+"'")
			root = _get_XML_tag_value(node)
			root_processed = True
			
		elif node.localName == "path":
			if path_processed:
				logging.warning("Duplicate entry 'path' in '"+source+"'")
			path = _get_XML_tag_value(node)
			path_processed = True
			
		elif node.localName is not None:
			logging.warning("Unknown tag '"+node.localName+"' in '"+source+"'. Skipping.")

	
	"""Check for missing parameters"""
	if not name:
		logging.warning("Missing 'name' for index in '"+source+"'.")
		name = UNDEFINED_NAME
	if not root:
		logging.warning("Missing 'root' for index in '"+source+"'.")
		return False
	if not path:
		logging.warning("Missing 'path' for index in '"+source+"'.")
		return False
	
	"""Return the CollectionIndex object"""
	return CollectionIndex(name, root, path)


def _get_XML_tag_value(node, source = None):
	"""
	Returns the string contained in the given DOM Node, or an error if the node
	does not contain a string (e.g. other nodes).
	
		'node'		is the DOM Node
		'source'	Is an identifier of the source (e.g. the XML file), will be
					displayed in case of error
	"""

	if source is not None:
		source_msg = " in '"+source+"'"
	else:
		source_msg = ""

	if len(node.childNodes) != 1:
		logging.warning("Invalid content for '"+node.localName+"'"+source_msg)
		return False
	
	return node.childNodes[0].nodeValue
	
#
# CLASSES
#

class Movie(object):
	
	PROPERTIES = ["title", "year", "genre"]
	
	def __init__(self, title, year, genre, files):
		self.title = title
		self.year  = year
		self.genre = genre
		self.files = files
		
	def get_xml(self):
		"""
		Returns the movie in the fscat XML format.
		
		TODO: This should be replaced with a template engine
		"""
		
		r = "<media type='movie'>\n"
		
		for f in self.files:
			r += "	<file>"+f+"</file>\n"
		
		r += "	<title>"+self.title+"</title>\n"
		r += "	<year>"+self.year+"</year>\n"
		r += "	<genre>"+self.genre+"</genre>\n"
		
		return r+"</media>"

class Collection(object):
	
	def __init__(self, name, indices):
		self.name    = name
		self.indices = indices
	

class CollectionIndex(object):
	
	def __init__(self, name, root, path):
		self.name = name
		self.root = root
		self.path = path


#
# MAIN
#

if __name__ == '__main__':
	logging.basicConfig(level=logging.WARNING)
	
	try:
		if (sys.argv[1] == "build"):
			if build_indices():
				print("Indices successfully built")
			else:
				print("Errors occurred. No index was built.")
				
		elif (sys.argv[1] == "edit"):
			#~ try:
			edit_meta(sys.argv[2])
			#~ except IndexError:
				#~ print("USAGE: fscat edit PATH")
		
		elif (sys.argv[1] == "init"):
			try:
				d = sys.argv[2]
			except IndexError:
				d = DIR_DATA
			
			if init_meta(d):
				print("Medadata initialized correctly")
			else:
				print("Errors occurred. Metadata initialization not completed.")
		
		elif (sys.argv[1] == "help"):
			print("Fscat "+__version__)
			print("No help screen available... Check the code.")
		
		else:
			print("Invalid parameter: "+sys.argv[1])
	except IndexError:
		print("USAGE: fscat COMMAND [OPTIONS]")
